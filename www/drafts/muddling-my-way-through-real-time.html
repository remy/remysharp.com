<!DOCTYPE html><html id="remysharp-com"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Muddling my way through real time</title><meta name="description" content="About [code] and all that jazz"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="shortcut icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="/css/screen.css?2.5"><link rel="stylesheet" type="text/css" href="/css/zenburn.css?2.5"><link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="http://feeds.feedburner.com/remysharp"><link rel="alternate" type="text/xml" title="RSS .92" href="http://feeds.feedburner.com/remysharp"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="http://feeds.feedburner.com/remysharp"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-1656750-1', 'auto');
ga('send', 'pageview');</script></head><body id="drafts-muddling-my-way-through-real-time-page"><nav class="main-nav clearfix subpanel"><nav class="main-nav clearfix subpanel"><ul class="post-nav"><li class="home"><a href="/">Home</a></li><li class="next"><a href="/2014/09/18/wordpress-ghost-harp-pt1" title="WordPress -&gt; Ghost -&gt; Harp (part 1)">Latest post</a></li></ul></nav></nav><main role="main" class="content"><div class="warning">Draft posts are a work in progress.&nbsp;Last edited 18-Sep 2014</div><article class="post"><h1 class="title"><a href="/drafts/muddling-my-way-through-real-time">Muddling my way through real time</a><small class="edit"><a href="https://github.com/remy/remysharp.com/blob/master/public/drafts/muddling-my-way-through-real-time.md">(edit)</a></small></h1><div class="post-content">
<p>Real time demand is a core part of our internet experience, let alone expectation.</p>
<p>Twitter is probably the crowning application of real time I can think of. Hitting the mass audience and industries across the board.</p>
<p>Today we have real time journalism, data, feedback, communication between our teams, from our code and tests. Heck, we can create a brand new virtual machine in under 60 seconds ready to deploy a new site.</p>
<p>I recently returned from jsconf.eu 2014, and sitting in the office, only days later I kept catching myself thinking &quot;I&#39;ll just watch the video from jsconf–&quot; - but what video? They filmed their events, but somehow I was expecting the event to have already fully edited, titled, uploaded and release <em>all</em> their videos! I know some events that do do this (<a href="http://lxjs.org">lxjs</a> for one) - but these aren&#39;t the norm. At what point did I have this (I think) unreasonable expectation on information on the web?</p>
<p>On demand and real time is the world we live in today. And if you can&#39;t handle the demand, your visitor will head off elsewhere.</p>
<!--more-->

<p><img src="/images/muddling-in-real-time-cover.gif" alt="Muddling your way in real time"></p>
<hr>
<p>I think its important to distinguish between what&#39;s technically real time and what a user perceives as real time. The later being important and the former being arbitrary.</p>
<p>Some applications have been know to respond <em>so</em> quickly that they had to introduce a fake delay to meet their users expectations. Specifically: when the program responded so instantly, the user thought something was wrong. With a small delay and a touch of UI feedback (along the lines of &quot;we&#39;ve processing your request&quot;), the user <em>felt</em> the a application was more responsive. (TODO provide references).</p>
<p>This is my own story of how I discovered the web in real time, what I&#39;ve done over the years and how I use node.js to simplify what used to be very technical problem.</p>
<h2>In the beginning...</h2>
<p>My first experience with a real time web was around 2002. I worked for many years on a finance research web site, and stock prices were an important aspect of data.</p>
<p>If you wanted live prices on your site at the time, there would be expensive licences with the London Stock Exchange and some form of Java Applet on your site. We settled for a recurring job that grabbed a 15 minute delayed price CSV file from Yahoo.</p>
<p><img style="width: 40%; display: block; margin: 0 auto;" src="/images/hahabusiness.jpg" title="What it's like to work for the finance sector"></p>
<p>The meant that our prices would be &quot;15 minute delayed&quot; (which was a normal expectation of prices shown on free web sites) but for the subsequent 15 minutes the prices would go stale.</p>
<p>It was one afternoon that one of the data collection team asked me to take a look at one of the finance research sites that they were looking at: Hemscott (I should add the original pages have long since left the web).</p>
<p>The page had a <a href="http://en.wikipedia.org/wiki/Heat_map">heatmap</a> of the FTSE100 prices. What made this particular page interesting is that the prices were changing in real time, and the red/green/sneutral were also changing, so there was a clear visual feedback system to show me this data was live.</p>
<p>What made this page magical though, was I ran the usual &quot;select text test&quot;. i.e. if I can select the text, then it&#39;s &quot;of the web&quot;. If I can&#39;t, it&#39;s Flash or Java Applets (and right clicking would discover which). But this <em>was</em> web. There was a DOM.</p>
<p><img src="/images/hemscott.gif" alt="Hemscott from 2002"></p>
<p><small>(Appologies for the poor picture above: the internet really <em>doesn&#39;t</em> remember!)</small></p>
<p>I spent quite a lot of time poking around some compressed JavaScript, looking at the DOM updating (this was back in the Firebug days so there was no <a href="https://developer.chrome.com/devtools/docs/dom-and-styles#setting-dom-breakpoints">break on DOM subtree modification</a>).</p>
<p>Hemscott had been able to do what we could not: real time prices, using web technology. <strong>It was magic.</strong> That&#39;s all I could ascertain.</p>
<hr>
<p>In retrospect (over several years) I realised that they were achieving the real time effect using Flash. Specifically the <code>XMLSocket</code> to connect to the streaming server and using the &quot;Flash SWF ExternalInterface Bridge&quot; to let JavaScript receive messages from the live stream.</p>
<p>Essentially a very similar technique that&#39;s used in today&#39;s <a href="https://github.com/gimite/web-socket-js">WebSocket polyfill</a> (which uses Flash for the filling part).</p>
<p>In the mean time Google released Google Talk which was the big tipping point in the web&#39;s history for shifting from a request/response pattern, to a server-push pattern, Ajax and Comet respectively.</p>
<h2>From an annoyance to the real time web</h2>
<p>Comet is a term that <a href="http://infrequently.org">Alex Russell</a> (of Dojo fame, and now simply known as The Oracle at Google/he works on Blink) <a href="http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/">defined</a> as a method to push data from the server to the client (the browser).</p>
<p>Comet is not a specific technology, but more of an abstracted process. The implementation varied, and frankly at the time, was better suited to system engineers rather than your cowboy developer...like me.</p>
<p>Comet <em>could</em> involve any mix of iframes (of course!), long polling, XHR, long running script tags, and so on. To add to complexity, there were oddly named protocols like the Bayeux protocol and BOSH.</p>
<p>All things that provided barrier to entry, but real time, rightly, was hard.</p>
<hr>
<p>Google launched GTalk in 2005 (as part of Gmail) and at the time Google were employing ex-Microsoft developers to solve a very, <em>very</em> specific problem. GTalk used long lived iframes to push the chat events up to the client.</p>
<p>But &quot;long lived&quot; means that they needed to refresh (or specifically: reload) eventually, and that reload in IE would cause an <a href="javascript:window.xpaudio.play()">audible clicking noise</a> (this was actually a feature of XP&#39;s audio suite). Imagine for a moment, that clicking, coming from seemingly nowhere, on a regular basis when you&#39;re chatting online with your friends. Annoying!</p>
<audio id="xpaudio" controls style="width: 100%;" src="/downloads/clicking.wav"></audio>

<p>The solution is amazing (or certainly to me) and the epitome of the web: a hack upon hack upon hack.</p>
<p><a href="http://infrequently.org/2006/02/what-else-is-burried-down-in-the-depths-of-googles-amazing-javascript/">The solution</a> would be to create an ActiveX htmlfile object, drop the document with an iframe inside that and the clicking would be suppressed.</p>
<p>And so a stable server push technology emerged.</p>
<hr>
<p>Real time appeared more and more across the web. There was even a product for the finance industry called LightStreamer (which I was even asked by my managers to reverse engineer...which was fun with packed minified files...).</p>
<p>The real hurdle is that there&#39;s <em>two</em> parts to real time: client <em>and</em> the server.</p>
<p>The usual set up for a server in the mid-2000s was to use a <a href="http://en.wikipedia.org/wiki/LAMP_(software_bundle">LAMP stack</a>). The A standing for Apache was the main sticking point.</p>
<p>Apache is designed (out of the box) to run and spawn a number of processes to deal with concurrent requests.</p>
<p>So if you have 100 apache processes waiting to deal with web requests, and you have 101 requests, the 101st user will have to wait until there&#39;s a free process before apache can respond.</p>
<p>This is usually find when you&#39;re deal with a request/response situation, apache is fast for that. But when you&#39;re keeping connections open to allow a server to <em>push</em> a message to the client, you saturate the available apache processes.</p>
<p>What does this mean in practise? If you have 100 processes and 101 streaming requests, the 101st <em>will never</em> receive a response. And to that user, the site is hanging indefinitely.</p>
<p>The solution to the server issue is evented server. If I recall correctly, this would be :Twisted for Python, Jakarta for Java, Juggernaut for Ruby, etc. But they were non-trivial to set up. I&#39;ll explain an evented server later.</p>
<p>Come 2009 and Ryan Dahl.</p>
<h2>Node is introduced</h2>
<p><img src="/images/ryan-node.jpg" alt="Ryan introduces Node at jsconf"></p>
<p>At the first jsconf.eu, Ryan Dahl, introduced <a href="http://lanyrd.com/2009/jsconfeu/skpz/">node.js: evented IO for V8</a>.</p>
<p>The talk starts quite technical and detailed, but Ryan started to draw similarities with what he was doing with node.js with the DOM.</p>
<p>Although node.js has nothing to do with the DOM, the way that the event loop works is very similar to the way a browser will work.</p>
<h3>The event loop</h3>
<p>This is what an event loop <em>could</em> look like:</p>
<pre><code class="language-lua">function main
  initialize()
  while message != quit
    message := get_next_message()
    process_message(message)
  end while
end function</code></pre>
<p>In a browser, the <code>get_next_message</code> could be the user moving the mouse, or clicking, or an XHR request completing, or a render, or some JavaScript being run. The point being is that the loop waits for a task, then processes that task.</p>
<p>This is where node.js makes concurrent requests (i.e. holding 100s if not 1000s of open connections to clients) easy.</p>
<h3>Hello world of real time</h3>
<p>As Ryan demoed in his talk 5 years ago, the code following is the simple proof that comet servers are incredibly simple with Node. The key with the server side is being able to hang inbound requests <em>whilst</em> also getting on with other work, like accepting more inbound requests.</p>
<pre><code class="language-js">var http = require(&#39;http&#39;);

var server = http.createServer(function (req, res) {
  res.writeHead(200, { &#39;content-type&#39;: &#39;text/html&#39; });
  res.write(&#39;&lt;script&gt;console.log(&quot;this is the start of the stream...&quot;)&lt;/script&gt;&#39;);

  var timer = setInterval(function () {
    // if the connection has closed, and we can&#39;t write anymore
    if (!res.connection || !res.connection.writable) {
      // then clear this interval, and *attempt* to end the response
      clearInterval(timer);
      res.end();
    } else {
      // otherwise, keep sending a script with logging
      res.write(&#39;&lt;script&gt;console.log(&quot;and now more messages...&quot;)&lt;/script&gt;&#39;);
    }
  }, 2000);
});

server.listen(8080);</code></pre>
<p>This code is saved to <code>server.js</code> and run using <code>node server.js</code> and now I can visit <code>localhost:8080</code> on my machine, and it should start logging, in 2 second increments &quot;and now more messages...&quot; (<a href="http://lit-thicket-2959.herokuapp.com/">live demo version that writes to the DOM</a>).</p>
<p>A comet server has a bit more to it, but with this simple few lines of code we can create as many persistent connection as we like and our server will continue to accept requests.</p>
<p>During the timeout, the server isn&#39;t &quot;sleeping&quot;, it&#39;s <em>waiting</em> for the next event, be it the time it to fire, or for another request to come in.</p>
<p>Equally we can easily give the server <em>more</em> things to do with the single event loop. It could be collecting live prices from a server, or making APIs calls, or have its own scheduling task all inside the single program <em>because</em> of the way node.js is architectured.</p>
<p>What&#39;s particularly elegant about node.js today, is that it&#39;s incredibly simple to install, has first class support across all three platforms (windows, linux and mac) and is extremely well documented and supported by the community.</p>
<h2>Codifying into standards</h2>
<p>As time passed, using Flash and various hacks to achieve real time eventually landed into the standards, typically under the umbrella term of HTML5.</p>
<p>That&#39;s to say, today we have <em>three</em> native client side solutions to communicating with the server:</p>
<ol>
<li><a href="http://caniuse.com/#search=xhr2">Ajax</a>. Well known. Well loved. Well understood. The XHR2 spec takes the API further and gives us much more functionality.</li>
<li><a href="http://caniuse.com/#search=websockets">WebSockets</a>. Bi-directional, persistent sockets, that can be made across origin.</li>
<li><a href="http://caniuse.com/#search=eventsource">EventSource</a>. Push based server <em>events</em>, that automatically reconnect when the connection is dropped.</li>
</ol>
<p>These standards are good because: all browsers implementing new features will implement these features in an interopable way. With the exception of EventSource, all these are supported by IE10 and all other browsers (and EventSource has excellent support through <a href="">polyfills</a>).</p>
<h2>So, what&#39;s next?</h2>
<p>Now we live in a world where both the client side <em>and</em> server side has been solved and is simple to work with, what can we actually do?</p>
<p>Here&#39;s a few examples of where I&#39;ve used node.js for real time:</p>
<ul>
<li>Live reload remote devices with user generated content (in JS Bin)</li>
<li>Codecasting - like screencasting, but with HTML, CSS &amp; JavaScript</li>
<li>Remote console injection - for running a desktop console against any mobile device (like old Android or Windows phone)</li>
<li>Proxy sensor events - streaming the accelerometer from a mobile device to desktop for testing</li>
<li>User discovery - for a two player game waiting for each other to join the session (like two users joining a chat room)</li>
<li>Push notification to browser for both progress events and when a long task has completed</li>
</ul>
<p>A lot of this is made very easy with existing node modules developed by the node community, and stress tested by everyone else.</p>
<h2>Core npm modules</h2>
<p>As I&#39;m sure many of you know, the node module repository is rife with libraries to do just about <a href="https://www.npmjs.org/package/true">everything</a>. The libraries that handle real time communication have been baked, and run through the mill pretty hard and there&#39;s lot of good choice nowadays.</p>
<p>What&#39;s particularly useful about many of these libraries is that they provide both sides of the infrastructure required to achieve real time, and usually require very little to get started.</p>
<h3>Socket.IO</h3>
<p>Possibly the most well known, and recently moved to 1.0.</p>
<ul>
<li>libraries</li>
<li>npm</li>
<li>socket.io</li>
<li>options</li>
<li>notes about mobile!!!</li>
</ul>
<h2>Long-latency real time feedback</h2>
<p>One aspect that particularly interests me is long running requests. For example, when I created 5minfork (a site that clones a github repo and hosts it for 5 minutes), there&#39;s a point when the user requests to clone a git repo and there&#39;s a latency period.</p>
<p>This period length is unknown (i.e. we could be cloning a large project which takes time), but we do know that it&#39;s not instant. So how do we communicate to the user that work is in progress and <em>most importantly</em> tell the user that the work is done and they can proceed?</p>
<p>Easily with node.js.</p>
<p>[example]</p>
<p class="update">Drafts may be incomplete or entirely abandonded, so please forgive me. If you find an issue with a draft, or would like to see me write about something specifically, please try <a href="http://github.com/remy/remysharp.com/issues/new">raising an issue</a>.</p></div></article></main><footer class="site-footer clearfix flex subpanel"><div class="flex-item archives"><h2>Archives</h2><ul><li><a href="/archive">All years</a></li><li><a href="/2014">2014</a></li><li><a href="/2013">2013</a></li><li><a href="/2012">2012</a></li><li><a href="/2011">2011</a></li><li><a href="/2010">2010</a></li><li><a href="/2009">2009</a></li><li><a href="/2008">2008</a></li><li><a href="/2007">2007</a></li><li><a href="/2006">2006</a></li></ul></div><div class="flex-item links"><h2>Links</h2><ul><li><a href="/about">About Remy</a></li><li><a target="_blank" href="/feed.xml">RSS feed</a></li><li><a target="_blank" href="https://github.com/remy">On GitHub</a></li><li><a target="_blank" href="https://twitter.com/rem">On Twitter</a></li><li><a target="_blank" href="http://lanyrd.com/profile/rem/past/speaking/">Presentations</a></li></ul></div><div class="flex-item license"><h2>License</h2><p class="vcard">All content by <a class="url fn" href="http://remysharp.com">Remy Sharp</a> and under <a href="http://creativecommons.org/licenses/by-nc-sa/2.0/uk/">creative commons</a> and code under <a href="http://rem.mit-license.org">MIT license</a>.</p><p>All code and content for this blog is available as <a href="https://github.com/remy/remysharp.com">open source on GitHub</a>.</p>
</div></footer><script src="http://code.jquery.com/jquery-1.11.1.min.js"></script><script>window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/jquery.fitvids.js"></script><script src="/js/highlight.min.js"></script><script src="/js/permalink.js?2.5"></script><script src="/js/index.js?2.5"></script><!--  
  
 Carved up by hand using Harp and a shit load of hacking.
  
  Also, this:
  
  
  
                       \_            /;              _.._
                       `\~--.._     //'            ,(+=\\\\
                        `//////\  \\/;'             /~ (\\\\
                          ~/////\~\`)'             /;   ))))
                              `~'  |              ((`~/((((\
                              ;'_\'\             /'))   )))))
                             /~/ '" "'     _.  /'/\_ /^\`((( \
                            `\/'       _.-~/--/ (  =(   | ,  |
                                    _/~\_)_}___/^\/~`\.__\|==|
                                   /uUUU)        )        |  |
                                  (   / |      _-=o|\__ /'/~ \
                                  ' /'  |     /(((((\`\(  |~\/
                                  /'    |   /' )))))"`\`\|/_/---.._,$$,
                            .,ssS$$$Sss|._/_..-((('    )\)>>>      ~\$
                         ,sS$$$$$$$$$$$|$$$$$$$  |/    //'~`o        `\
                       ,$$$$$$$$$$$$$$|$$S$$$$'  (    /                \
                     ,$$$$$$$$$$$$S$$|$$$$$$$'   |   /              ,s$$$
                   s$$$$$S$$$$$$$$$S|$$$$$$$$    |  /              $$$$$$
                 _~,$S""''     ``"S|$$S$$$$$"    (_,`\,          ,$$$$$$$;
               /~ ,"'             / 'S$$$$$"      \_./|        s$$$$$$$$$$
            (~'      _,  \==~~)  /     """         \  |       $$$$$$$$$$$$
             (0\   /0/     \-' /'                   \ |  |  ,$$$$$$$$$$$$$,
             `/'  '         _-~                     |= \_-\ $$$$$$$$$$$$$$s
             (~~~)      _.-~_-   \             \  ,s|= |   `"$$$$$$$$$$$$$$$
            ( `-'  )/>-~  _/-__   |            |,$$$|_/,      `"$$$$$$$$$$$$
            /V^^^^V~/' _/~/~~  ~~-|            |$$$$$$$$         "$$$$$$$$$$,
           /  (^^^^),/' /'        )           /S$$$$$$$;         ,$$$$$$$$$$$,
         ,$$_  `~~~'.,/'         /     _-ss, /(/-(/-(/'        ,s$$$$$$$$$$$$$
       ,s$$$$$ssSS$$$'         ,$'.s$$$$$$$$'                  (/-(/-(/-(/-(/'
      S$$$$$$$$$$$$$$        ,$$$$$$$$$$$$$'
     (/-(/-(/-(/-(/'      _s$$$$$$$$$$$$$$
                         (/-(/-(/-(/-(/-'
  
  
  
     – Remy
  
  --><!-- Env: production - static files--></body></html>